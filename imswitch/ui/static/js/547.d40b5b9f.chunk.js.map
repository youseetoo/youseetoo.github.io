{"version":3,"file":"static/js/547.d40b5b9f.chunk.js","mappings":"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","sources":["../node_modules/zstddec/zstddec.ts","../node_modules/geotiff/dist-module/globals.js","../node_modules/geotiff/dist-module/compression/lerc.js","../node_modules/lerc/LercDecode.js"],"sourcesContent":["interface DecoderExports {\n\tmemory: Uint8Array;\n\n\tZSTD_findDecompressedSize: (compressedPtr: number, compressedSize: number) => BigInt;\n\tZSTD_decompress: (uncompressedPtr: number, uncompressedSize: number, compressedPtr: number, compressedSize: number) => number;\n\tmalloc: (ptr: number) => number;\n\tfree: (ptr: number) => void;\n}\n\nlet init: Promise<void>;\nlet instance: {exports: DecoderExports};\nlet heap: Uint8Array;\n\nconst IMPORT_OBJECT = {\n\n\tenv: {\n\n\t\temscripten_notify_memory_growth: function ( index: number ): void {\n\n\t\t\theap = new Uint8Array( instance.exports.memory.buffer );\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * ZSTD (Zstandard) decoder.\n */\nexport class ZSTDDecoder {\n\n\tinit (): Promise<void> {\n\n\t\tif ( init ) return init;\n\n\t\tif ( typeof fetch !== 'undefined' ) {\n\n\t\t\t// Web.\n\n\t\t\tinit = fetch( 'data:application/wasm;base64,' + wasm )\n\t\t\t\t.then( ( response ) => response.arrayBuffer() )\n\t\t\t\t.then( ( arrayBuffer ) => WebAssembly.instantiate( arrayBuffer, IMPORT_OBJECT ) )\n\t\t\t\t.then( this._init );\n\n\t\t} else {\n\n\t\t\t// Node.js.\n\n\t\t\tinit = WebAssembly\n\t\t\t\t.instantiate( Buffer.from( wasm, 'base64' ), IMPORT_OBJECT )\n\t\t\t\t.then( this._init );\n\n\t\t}\n\n\t\treturn init;\n\n\t}\n\n\t_init ( result: WebAssembly.WebAssemblyInstantiatedSource ): void {\n\n\t\tinstance = result.instance as unknown as { exports: DecoderExports };\n\n\t\tIMPORT_OBJECT.env.emscripten_notify_memory_growth( 0 ); // initialize heap.\n\n\t}\n\n\tdecode ( array: Uint8Array, uncompressedSize = 0 ): Uint8Array {\n\n\t\tif ( ! instance ) throw new Error( `ZSTDDecoder: Await .init() before decoding.` );\n\n\t\t// Write compressed data into WASM memory.\n\t\tconst compressedSize = array.byteLength;\n\t\tconst compressedPtr = instance.exports.malloc( compressedSize );\n\t\theap.set( array, compressedPtr );\n\n\t\t// Decompress into WASM memory.\n\t\tuncompressedSize = uncompressedSize || Number( instance.exports.ZSTD_findDecompressedSize( compressedPtr, compressedSize ) );\n\t\tconst uncompressedPtr = instance.exports.malloc( uncompressedSize );\n\t\tconst actualSize = instance.exports.ZSTD_decompress( uncompressedPtr, uncompressedSize, compressedPtr, compressedSize );\n\n\t\t// Read decompressed data and free WASM memory.\n\t\tconst dec = heap.slice( uncompressedPtr, uncompressedPtr + actualSize );\n\t\tinstance.exports.free( compressedPtr );\n\t\tinstance.exports.free( uncompressedPtr );\n\n\t\treturn dec;\n\n\t}\n\n}\n\n/**\n * BSD License\n *\n * For Zstandard software\n *\n * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name Facebook nor the names of its contributors may be used to\n *    endorse or promote products derived from this software without specific\n *    prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// wasm:begin\nconst wasm = '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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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';\n// wasm:end\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","import { inflate } from 'pako';\nimport Lerc from 'lerc';\nimport { ZSTDDecoder } from 'zstddec';\nimport BaseDecoder from './basedecoder.js';\nimport { LercParameters, LercAddCompression } from '../globals.js';\n\nexport const zstd = new ZSTDDecoder();\n\nexport default class LercDecoder extends BaseDecoder {\n  constructor(fileDirectory) {\n    super();\n\n    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;\n    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;\n\n    this.addCompression = fileDirectory.LercParameters[LercParameters.AddCompression];\n  }\n\n  decodeBlock(buffer) {\n    switch (this.addCompression) {\n      case LercAddCompression.None:\n        break;\n      case LercAddCompression.Deflate:\n        buffer = inflate(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      case LercAddCompression.Zstandard:\n        buffer = zstd.decode(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      default:\n        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);\n    }\n\n    const lercResult = Lerc.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });\n    const lercData = lercResult.pixels[0];\n    return lercData.buffer;\n  }\n}\n","/* jshint forin: false, bitwise: false */\n/*\nCopyright 2015-2021 Esri\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function() {\n  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). \n  //the exported module handles format variation autoamtically.\n\n  //the original LercDecode for Version 1\n  var LercDecode = (function() {\n\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n\n    var CntZImage = {};\n\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image's width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n    CntZImage.decode = function(input, options) {\n      options = options || {};\n\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\n\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\n        options.encodedMaskData, noDataValue, options.returnMask);\n\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE, currentValue;\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\n\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n\n      var xx, yy;\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n\n          var block = data.pixels.blocks[blockIdx];\n\n          var blockData, blockPtr, constValue;\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n            blockPtr = 0;\n          }\n          else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          }\n          else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n                  resultPixels[outPtr++] = noDataValue;\n                }\n                maskByte <<= 1;\n              }\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n                outPtr += outStride;\n              }\n            }\n            else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n                outPtr += outStride;\n              }\n            }\n          }\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\n            throw \"Block and Mask do not match\";\n          }\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function(data) {\n      return {\n        \"fileIdentifierString\": data.fileIdentifierString,\n        \"fileVersion\": data.fileVersion,\n        \"imageType\": data.imageType,\n        \"height\": data.height,\n        \"width\": data.width,\n        \"maxZError\": data.maxZError,\n        \"eofOffset\": data.eofOffset,\n        \"mask\": data.mask ? {\n          \"numBlocksX\": data.mask.numBlocksX,\n          \"numBlocksY\": data.mask.numBlocksY,\n          \"numBytes\": data.mask.numBytes,\n          \"maxValue\": data.mask.maxValue\n        } : null,\n        \"pixels\": {\n          \"numBlocksX\": data.pixels.numBlocksX,\n          \"numBlocksY\": data.pixels.numBlocksY,\n          \"numBytes\": data.pixels.numBytes,\n          \"maxValue\": data.pixels.maxValue,\n          \"noDataValue\": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function(data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function(input, fp, skipMask) {\n      var data = {};\n\n      // File header\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\n      }\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24;\n\n      // Mask Header\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16;\n\n        // Mask Data\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        }\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      }\n\n      // Pixel Header\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY;\n      // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0); size++;\n          block.encoding = headerByte & 63;\n          if (block.encoding > 3) {\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\n          }\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n          if ((headerByte !== 0) && (headerByte !== 2)) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1); size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true); size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true); size += 4;\n            } else {\n              throw \"Invalid block offset type\";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size); size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size); size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true); size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true); size += 4;\n              } else {\n                throw \"Invalid valid pixel count type\";\n              }\n            }\n          }\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n            if (numPixels !== Math.floor(numPixels)) {\n              throw \"uncompressed block has invalid length\";\n            }\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0, o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale);\n      // get rid of trailing bytes that are already part of next block\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n        if (bitsLeft >= bitsPerPixel) {\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = (bitsPerPixel - bitsLeft);\n          n = ((buffer & bitMask) << missingBits) & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += (buffer >>> bitsLeft);\n        }\n        //pixel values may exceed max due to quantization\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n      return dest;\n    };\n\n    return CntZImage;\n  })();\n\n  //version 2. Supports 2.1, 2.2, 2.3\n  var Lerc2Decode = (function() {\n    \"use strict\";\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\n          }\n        }\n        else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\n        var buffer;\n        var dest = [];\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);//1st one\n        return dest;\n      },\n\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            dest[o] = lutArr[n];\n          }\n        }\n        else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n        return dest;\n      },\n\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);\n        return dest;\n      },\n\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          }\n          else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          dest[o] = n;\n        }\n        return dest;\n      },\n\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        //micro-optimizations\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          dest[o] = n;\n        }\n        return dest;\n      }\n    };\n\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function(input) {\n\n        var sum1 = 0xffff, sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n        while (words) {\n          var tlen = (words >= 359) ? 359 : words;\n          words -= tlen;\n          do {\n            sum1 += (input[i++] << 8);\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        }\n\n        // add the straggler byte if it exists\n        if (len & 1) {\n          sum2 += sum1 += (input[i] << 8);\n        }\n        // second reduction step to reduce sums to 16 bits\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n\n      readHeaderInfo: function(input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\n        }\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n          ptr += 4;\n        }\n\n        //keys start from here\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n        headerInfo.width = view.getUint32(4, true); //ncols\n        ptr += 8;\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        }\n        else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n\n        var checksum, keyLength;\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n          if (checksum !== headerInfo.checksum) {\n            throw \"Checksum failed.\";\n          }\n        }\n        return true;\n      },\n\n      checkMinMaxRanges: function(input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += (2 * rangeBytes);\n        var i, equal = true;\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        return rawData;\n      },\n\n      readMask: function(input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4;\n\n        // Mask Data\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw (\"invalid mask\");\n        }\n        var bitset, resultMask;\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0, val = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0, k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            }\n            else {\n              mb = bitset[k >> 3];\n            }\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n          data.pixels.resultMask = resultMask;\n\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n\n      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\n        //data.pixels.numBytes = numBytes;\n        var rawData;\n        var mask = data.pixels.resultMask;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        if (rawData.length === numPixels * numDims) {\n          if (useBSQForOutputDim) {\n            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);\n          }\n          else {\n            data.pixels.resultPixels = rawData;\n          }\n        }\n        else  //mask\n        {\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n          var z = 0, k = 0, i = 0, nStart = 0;\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k;\n                  for (i = 0; i < numDims; i++, nStart+=numPixels) {\n                    data.pixels.resultPixels[nStart] = rawData[z++];\n                  }\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    data.pixels.resultPixels[nStart + i] = rawData[z++];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = rawData[z++];\n              }\n            }\n          }\n        }\n        ptr += numBytes;\n        data.ptr = ptr;       //return data;\n        return true;\n      },\n\n      readHuffmanTree: function(input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading code table\n        *************************/\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n        if (version < 2) {\n          throw \"unsupported Huffman version\";\n        }\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n        if (i0 >= i1) {\n          return false;\n        }\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n        var bitPos = 0, word, srcPtr = 0;\n        word = stuffedData[0];\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            }\n            else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> (32 - bitPos);\n            }\n          }\n        }\n\n        //finished reading code table\n\n        /* ************************\n        * building lut\n        *************************/\n        var numBitsLUT = 0, numBitsLUTQick = 0;\n        var tree = new TreeNode();\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        }\n        else {\n          numBitsLUTQick = numBitsLUT;\n        }\n        // for debugging purpose\n        // if (numBitsLUT >= 30) {\n        //   console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\n        // }\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            entry = [len, j];\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << (numBitsLUTQick - len);\n              numEntries = 1 << (numBitsLUTQick - len);\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            }\n            else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n                  node = node.right;\n                }\n                else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n                  node = node.left;\n                }\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n\n      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height;\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading huffman structure info\n        *************************/\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree;\n        //stuffedData includes huffman headers\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim;\n        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out\n        if (numDims < 2 || deltaEncode) {\n          for (iDim = 0; iDim < numDims; iDim++) {\n            if (numDims > 1) {\n              //get the mem block of current dimension\n              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n              prevVal = 0;\n            }\n            if (data.headerInfo.numValidPixel === width * height) { //all valid\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n    \n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n    \n                  delta = val - offset;\n                  if (deltaEncode) {\n                    if (j > 0) {\n                      delta += prevVal;    // use overflow\n                    }\n                    else if (i > 0) {\n                      delta += resultPixels[k - width];\n                    }\n                    else {\n                      delta += prevVal;\n                    }\n                    delta &= 0xFF; //overflow\n                    resultPixels[k] = delta;//overflow\n                    prevVal = delta;\n                  }\n                  else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            }\n            else { //not all valid, use mask\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  if (mask[k]) {\n                    val = 0;\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUTQick) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                    {\n                      val = decodeLut[valTmpQuick][1];\n                      bitPos += decodeLut[valTmpQuick][0];\n                    }\n                    else {\n                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                      if (32 - bitPos < numBitsLUT) {\n                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                        valTmpQuick = valTmp;// >>> deltaBits;\n                      }\n                      node = tree;\n                      for (ii = 0; ii < numBitsLUT; ii++) {\n                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                        node = currentBit ? node.right : node.left;\n                        if (!(node.left || node.right)) {\n                          val = node.val;\n                          bitPos = bitPos + ii + 1;\n                          break;\n                        }\n                      }\n                    }\n    \n                    if (bitPos >= 32) {\n                      bitPos -= 32;\n                      srcPtr++;\n                      word = stuffedData[srcPtr];\n                    }\n    \n                    delta = val - offset;\n                    if (deltaEncode) {\n                      if (j > 0 && mask[k - 1]) {\n                        delta += prevVal;    // use overflow\n                      }\n                      else if (i > 0 && mask[k - width]) {\n                        delta += resultPixels[k - width];\n                      }\n                      else {\n                        delta += prevVal;\n                      }\n    \n                      delta &= 0xFF; //overflow\n                      resultPixels[k] = delta;//overflow\n                      prevVal = delta;\n                    }\n                    else {\n                      resultPixels[k] = delta;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        else {\n          for (k = 0, i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n              k = i * width + j;\n              if (!mask || mask[k]) {\n                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;\n                  }\n                  if (decodeLut[valTmpQuick])\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n        }\n        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        data.pixels.resultPixels = resultPixelsAllDim;\n        //swap for BIP layout\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion;\n          //var block = {};\n          var blockPtr = 0;\n          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);\n          var view = new DataView(input, data.ptr, viewByteLength);\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\n          var numBits = headerByte & 31;\n          var numElements = 0;\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr); blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\n          } else {\n            throw \"Invalid valid pixel count type\";\n          }\n          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\n          //offset = offset || 0;\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            lutBitsPerElement = numBits;\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            bitsPerPixel = 0;\n            while ((lutBytes - 1) >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            //lutArr.unshift(0);\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n            else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          }\n          else {\n            //console.debug(\"bitstuffer\");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n              else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n\n      },\n\n      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var numPixels = width * height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims, iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        var fileVersion = headerInfo.fileVersion;\n        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;\n        var isDiffEncoding;\n        var zMax = headerInfo.zMax;\n        //var resultPixelsAllDim = resultPixels;\n        var resultPixelsPrevDim;\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\n\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixelsPrevDim = resultPixels;\n                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);\n                zMax = headerInfo.maxValues[iDim];\n              } else {\n                resultPixelsPrevDim = null;\n              }\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;\n              bits67 = (headerByte >> 6) & 0xFF;\n              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check\n              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {\n                throw \"integrity issue\";\n              }\n\n              if (isDiffEncoding && iDim === 0) {\n                throw \"integrity issue\";\n              }\n\n              blockEncoding = headerByte & 3;\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\n              }\n              else if (blockEncoding === 2) { //constant 0\n                if (isDiffEncoding) {\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        }\n                        outPtr++;\n                      }\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        outPtr++;\n                      }\n                    }\n                  }\n                }\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              }\n              else if (blockEncoding === 0) {  //uncompressed\n                if (isDiffEncoding) {\n                  // doesn't make sense, should not happen\n                  throw \"integrity issue\";\n                }\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\n                //bit alignment\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n                      outPtr++;\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                else {//all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                data.ptr += z * dataTypeSize;\n              }\n              else { //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n                if (blockEncoding === 3) //constant offset value\n                {\n                  data.ptr += blockPtr;\n                  data.counter.constantoffset++;\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n                else { //bitstuff encoding is 3\n                  data.ptr += blockPtr;\n                  //heavy lifting\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0;\n                  // duplicate code to favor performance, diff encoding is for multidimension only\n                  if (isDiffEncoding) {\n                    if (mask) {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          if (mask[outPtr]) {\n                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          }\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                    else {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                  }\n                  else if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n\n      formatFileInfo: function(data) {\n        return {\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\n          \"fileVersion\": data.headerInfo.fileVersion,\n          \"imageType\": data.headerInfo.imageType,\n          \"height\": data.headerInfo.height,\n          \"width\": data.headerInfo.width,\n          \"numValidPixel\": data.headerInfo.numValidPixel,\n          \"microBlockSize\": data.headerInfo.microBlockSize,\n          \"blobSize\": data.headerInfo.blobSize,\n          \"maxZError\": data.headerInfo.maxZError,\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          \"eofOffset\": data.eofOffset,\n          \"mask\": data.mask ? {\n            \"numBytes\": data.mask.numBytes\n          } : null,\n          \"pixels\": {\n            \"numBlocksX\": data.pixels.numBlocksX,\n            \"numBlocksY\": data.pixels.numBlocksY,\n            //\"numBytes\": data.pixels.numBytes,\n            \"maxValue\": data.headerInfo.zMax,\n            \"minValue\": data.headerInfo.zMin,\n            \"noDataValue\": data.noDataValue\n          }\n        };\n      },\n\n      constructConstantSurface: function(data, useBSQForOutputDim) {\n        var val = data.headerInfo.zMax;\n        var valMin = data.headerInfo.zMin;\n        var maxValues = data.headerInfo.maxValues;\n        var numDims = data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var i = 0, k = 0, nStart = 0;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        if (mask) {\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    resultPixels[nStart + k] = val;\n                  }\n                }\n              }  \n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    resultPixels[nStart + numDims] = maxValues[i];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                resultPixels[k] = val;\n              }\n            }\n          }\n        }\n        else {\n          if (numDims > 1 && valMin !== val) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  resultPixels[nStart + k] = val;\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                nStart = k * numDims;\n                for (i = 0; i < numDims; i++) {\n                  resultPixels[nStart + i] = maxValues[i];\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels * numDims; k++) {\n              resultPixels[k] = val;\n            }\n          }\n        }\n        return;\n      },\n\n      getDataTypeArray: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = Int8Array;\n            break;\n          case 1: //byte\n            tp = Uint8Array;\n            break;\n          case 2: //short\n            tp = Int16Array;\n            break;\n          case 3: //ushort\n            tp = Uint16Array;\n            break;\n          case 4:\n            tp = Int32Array;\n            break;\n          case 5:\n            tp = Uint32Array;\n            break;\n          case 6:\n            tp = Float32Array;\n            break;\n          case 7:\n            tp = Float64Array;\n            break;\n          default:\n            tp = Float32Array;\n        }\n        return tp;\n      },\n\n      getPixelType: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = \"S8\";\n            break;\n          case 1: //byte\n            tp = \"U8\";\n            break;\n          case 2: //short\n            tp = \"S16\";\n            break;\n          case 3: //ushort\n            tp = \"U16\";\n            break;\n          case 4:\n            tp = \"S32\";\n            break;\n          case 5:\n            tp = \"U32\";\n            break;\n          case 6:\n            tp = \"F32\";\n            break;\n          case 7:\n            tp = \"F64\";\n            break;\n          default:\n            tp = \"F32\";\n        }\n        return tp;\n      },\n\n      isValidPixelValue: function(t, val) {\n        if (val == null) {\n          return false;\n        }\n        var isValid;\n        switch (t) {\n          case 0: //char\n            isValid = val >= -128 && val <= 127;\n            break;\n          case 1: //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n          case 2: //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n          case 3: //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n          case 4: //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n          case 5: //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n          case 7:\n            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;\n            break;\n          default:\n            isValid = false;\n        }\n        return isValid;\n      },\n\n      getDataTypeSize: function(t) {\n        var s = 0;\n        switch (t) {\n          case 0: //ubyte\n          case 1: //byte\n            s = 1;\n            break;\n          case 2: //short\n          case 3: //ushort\n            s = 2;\n            break;\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n          case 7:\n            s = 8;\n            break;\n          default:\n            s = t;\n        }\n        return s;\n      },\n\n      getDataTypeUsed: function(dt, tc) {\n        var t = dt;\n        switch (dt) {\n          case 2: //short\n          case 4: //long\n            t = dt - tc;\n            break;\n          case 3: //ushort\n          case 5: //ulong\n            t = dt - 2 * tc;\n            break;\n          case 6: //float\n            if (0 === tc) {\n              t = dt;\n            }\n            else if (1 === tc) {\n              t = 2;\n            }\n            else {\n              t = 1;//byte\n            }\n            break;\n          case 7: //double\n            if (0 === tc) {\n              t = dt;\n            }\n            else {\n              t = dt - 2 * tc + 1;\n            }\n            break;\n          default:\n            t = dt;\n            break;\n        }\n        return t;\n      },\n\n      getOnePixel: function(block, blockPtr, offsetType, view) {\n        var temp = 0;\n        switch (offsetType) {\n          case 0: //char\n            temp = view.getInt8(blockPtr);\n            break;\n          case 1: //byte\n            temp = view.getUint8(blockPtr);\n            break;\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n          case 7:\n            temp = view.getFloat64(blockPtr, true);\n            break;\n          default:\n            throw (\"the decoder does not understand this pixel type\");\n        }\n        return temp;\n      },\n\n      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {\n        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;\n        if (numDims > 1) {\n          swap = new OutPixelTypeArray(numPixels * numDims);\n          if (inputIsBIP) {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[temp] = pixels[j++];\n              }\n            }  \n          }\n          else {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[j++] = pixels[temp];\n              }\n            }\n          }\n        }\n        return swap;\n      }\n    };\n\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n    var TreeNode = function(val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their's a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n       */\n      decode: function(/*byte array*/ input, /*object*/ options) {\n        //currently there's a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue;\n\n        //initialize\n        var i = 0, data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {};\n\n        // File header\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\n          return;\n        }\n\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\n\n        // version check\n        if (fileVersion > 5) {\n          throw \"unsupported lerc version 2.\" + fileVersion;\n        }\n\n        // Mask Header\n        Lerc2Helpers.readMask(input, data);\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        var useBSQForOutputDim = !options.returnPixelInterleavedDims;\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n          {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n            if (bReadDataOneSweep) {\n              //console.debug(\"OneSweep\");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);\n            }\n            else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\n                  throw \"Invalid Huffman flag \" + flagHuffman;\n                }\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\n                  //console.log(\"Huffman\");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n                else {\n                  //console.log(\"Tiles\");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n              }\n              else { //lerc2.x non-8 bit data\n                //console.log(\"Tiles\");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        }\n        else {\n          diff = data.headerInfo.blobSize - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask\n          //noDataValue: noDataValue\n        };\n\n        //we should remove this if there's no existing client\n        //optional noDataValue processing, it's user's responsiblity\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n          result.noDataValue = noDataValue;\n        }\n        data.noDataValue = noDataValue;\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n        return result;\n      },\n\n      getBandCount: function(/*byte array*/ input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n        return count;\n      }\n    };\n\n    return Lerc2Decode;\n  })();\n\n  var isPlatformLittleEndian = (function() {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  })();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values\n    **/\n    decode: function(encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw \"Big endian system is not supported.\";\n      }\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n      if (fileIdentifierString.trim() === \"CntZImage\") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      }\n      else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      }\n      else {\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\n      }\n\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n      var uniqueBandMaskCount = 0;\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,//for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,//lerc1 only\n          maskData: maskData,//lerc2 only\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\n          returnFileInfo: true,//for both lerc1 and lerc2\n          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only\n          pixelType: options.pixelType || null,//lerc1 only\n          noDataValue: options.noDataValue || null//lerc1 only\n        });\n\n        inputOffset = result.fileInfo.eofOffset;\n        maskData = result.maskData;//lerc2\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData;//lerc1\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1;\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = maskData;\n        }\n        if (majorVersion > 1) {\n          if (maskData) {\n            bandMasks.push(maskData);\n          }\n          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n            uniqueBandMaskCount++;\n          }\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n      var i, j, numPixels;\n      if (majorVersion > 1 && uniqueBandMaskCount > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (typeof define === \"function\" && define.amd) {/* jshint ignore:line */\n    //amd loaders such as dojo and requireJS\n    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\n    define([], function() { return Lerc; });/* jshint ignore:line */\n  }\n  else if (typeof module !== \"undefined\" && module.exports) {/* jshint ignore:line */\n    //commonJS module 1.0/1.1/1.1.1 systems, such as nodeJS\n    //http://wiki.commonjs.org/wiki/Modules\n    module.exports = Lerc;/* jshint ignore:line */\n  }\n  else {\n    //assign to this, most likely window\n    this.Lerc = Lerc;\n  }\n\n})();\n"],"names":["init","instance","heap","IMPORT_OBJECT","env","emscripten_notify_memory_growth","index","Uint8Array","exports","memory","buffer","wasm","fieldTagNames","fieldTags","key","hasOwnProperty","parseInt","BitsPerSample","ExtraSamples","SampleFormat","StripByteCounts","StripOffsets","StripRowCounts","TileByteCounts","TileOffsets","SubIFDs","fieldTypeNames","fieldTypes","LercParameters","LercAddCompression","geoKeyNames","geoKeys","zstd","fetch","then","response","arrayBuffer","WebAssembly","instantiate","this","_init","Buffer","from","result","decode","array","uncompressedSize","arguments","length","undefined","Error","compressedSize","byteLength","compressedPtr","malloc","set","Number","ZSTD_findDecompressedSize","uncompressedPtr","actualSize","ZSTD_decompress","dec","slice","free","LercDecoder","BaseDecoder","constructor","fileDirectory","super","planarConfiguration","PlanarConfiguration","samplesPerPixel","SamplesPerPixel","addCompression","decodeBlock","inflate","concat","Lerc","returnPixelInterleavedDims","pixels","LercDecode","CntZImage","input","options","skipMask","encodedMaskData","parsedData","parse","inputOffset","noDataValue","defaultNoDataValue","uncompressedData","uncompressPixelValues","pixelType","Float32Array","returnMask","width","height","pixelData","resultPixels","minValue","maxValue","resultMask","maskData","returnEncodedMask","mask","bitset","returnFileInfo","fileInfo","formatFileInfo","computeUsedBitDepths","bitDepths","data","TypedArrayClass","maskBitset","storeDecodedMask","currentValue","blockIdx","numX","numBlocksX","numY","numBlocksY","blockWidth","Math","floor","blockHeight","scale","maxZError","MAX_VALUE","xx","yy","blockDataBuffer","y","thisBlockHeight","x","thisBlockWidth","blockData","blockPtr","constValue","maskByte","outPtr","outStride","block","blocks","encoding","rawData","unstuff","stuffedData","bitsPerPixel","numValidPixels","offset","fileIdentifierString","fileVersion","imageType","eofOffset","numBytes","numBlocks","i","float32","Object","keys","fp","fileIdView","String","fromCharCode","apply","trim","view","DataView","getInt32","getUint32","getFloat64","getFloat32","ceil","cnt","getInt16","ip","op","getUint8","val","actualNumBlocksX","actualNumBlocksY","Array","blockI","blockY","blockX","size","bytesLeft","min","headerByte","offsetType","getInt8","numValidPixelsType","getUint16","arrayBuf","numPixels","ArrayBuffer","dataBytes","dataWords","Uint32Array","src","dest","o","n","bitMask","bitsLeft","nmax","numInvalidTailBytes","missingBits","Lerc2Decode","BitStuffer","lutArr","unshift","bitPos","Lerc2Helpers","HUFFMAN_LUT_BITS_MAX","computeChecksumFletcher32","sum1","sum2","len","words","tlen","readHeaderInfo","ptr","headerInfo","lastIndexOf","keyLength","checksum","numDims","numValidPixel","microBlockSize","blobSize","zMin","zMax","checkMinMaxRanges","OutPixelTypeArray","getDataTypeArray","rangeBytes","getDataTypeSize","minValues","readSubArray","maxValues","equal","readMask","mb","k","readDataOneSweep","useBSQForOutputDim","swapDimensionOrder","z","nStart","readHuffmanTree","BITS_MAX","i0","i1","decodeBits","j","codeTable","first","second","word","srcPtr","numBitsLUT","numBitsLUTQick","tree","TreeNode","max","entry","code","numEntries","jj","node","decodeLut","right","left","readHuffman","delta","valTmp","valTmpQuick","ii","huffmanInfo","prevVal","iDim","deltaEncode","encodeMode","resultPixelsAllDim","viewByteLength","bits67","doLut","numBits","numElements","store8","lutData","lutBytes","counter","lut","bitstuffer","readTiles","dataTypeSize","blockEncoding","isDiffEncoding","resultPixelsPrevDim","row","col","bytesleft","lastBlockHeight","lastBlockWidth","fileVersionCheckNum","uncompressed","getDataTypeUsed","getOnePixel","constantoffset","constant","getPixelType","constructConstantSurface","valMin","t","tp","Int8Array","Int16Array","Uint16Array","Int32Array","Float64Array","isValidPixelValue","isValid","s","dt","tc","temp","getUInt32","inputIsBIP","swap","onesweep","diff","bReadDataOneSweep","abs","flagHuffman","validPixelCount","dimCount","dimStats","getBandCount","count","isPlatformLittleEndian","a","b","encodedData","lerc","majorVersion","substring","bandMask","iPlane","eof","bandMasks","decodedPixelBlock","statistics","uniqueBandMaskCount","push"],"ignoreList":[],"sourceRoot":""}