(function(){"use strict";const h=[];for(let t=0;t<256;++t)h.push((t+256).toString(16).slice(1));function B(t,n=0){return(h[t[n+0]]+h[t[n+1]]+h[t[n+2]]+h[t[n+3]]+"-"+h[t[n+4]]+h[t[n+5]]+"-"+h[t[n+6]]+h[t[n+7]]+"-"+h[t[n+8]]+h[t[n+9]]+"-"+h[t[n+10]]+h[t[n+11]]+h[t[n+12]]+h[t[n+13]]+h[t[n+14]]+h[t[n+15]]).toLowerCase()}let S;const _=new Uint8Array(16);function V(){if(!S){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");S=crypto.getRandomValues.bind(crypto)}return S(_)}var E={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function U(t,n,r){if(E.randomUUID&&!t)return E.randomUUID();t=t||{};const e=t.random??t.rng?.()??V();if(e.length<16)throw new Error("Random bytes length must be >= 16");return e[6]=e[6]&15|64,e[8]=e[8]&63|128,B(e)}const v=1e-10,q=1e4;function I(t,n){return{x:t.x-n.x,y:t.y-n.y}}function W(t,n){return{x:t.x*n,y:t.y*n}}function b(t,n){return t.x*n.x+t.y*n.y}function P(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function k(t){const n=P(t);return n<v?{x:1,y:0}:{x:t.x/n,y:t.y/n}}function D(t,n){const r=n*Math.PI/180,e=Math.cos(r),i=Math.sin(r);return{x:t.x*e-t.y*i,y:t.x*i+t.y*e}}function R(t){return{x:-t.y,y:t.x}}function j(t,n){const r=[],e=t.params,i=e.rayCount||n.maxRays,a=e.wavelength||n.wavelength,s=e.divergence||0,l=e.beamDiameter||2,y=e.power||1,p=D({x:1,y:0},t.rotation);for(let f=0;f<i;f++){const C=i>1?(f/(i-1)-.5)*l:0,c=R(p),o={x:t.position.x+c.x*C,y:t.position.y+c.y*C};let u;if(s>0&&i>1){const g=(f/(i-1)-.5)*2*s;u=D(p,g)}else u=p;r.push({origin:o,direction:k(u),wavelength:a,intensity:y/i,id:U(),bounceCount:0,totalDistance:0})}return r}function A(t,n,r){const e=I(r,n),i=P(e);if(i<v)return null;const a=k(e),s=R(a),l=b(t.direction,s);if(Math.abs(l)<v)return null;const y=I(n,t.origin),p=b(y,s)/l;if(p<v)return null;const f={x:t.origin.x+t.direction.x*p,y:t.origin.y+t.direction.y*p},C=I(f,n),c=b(C,a);if(c<-v||c>i+v)return null;let o=s;return b(o,t.direction)>0&&(o=W(o,-1)),{point:f,distance:p,normal:o}}function T(t,n){const e=(n.params.aperture||25)/2,i=D({x:1,y:0},n.rotation),a=R(i),s={x:n.position.x-a.x*e,y:n.position.y-a.y*e},l={x:n.position.x+a.x*e,y:n.position.y+a.y*e},y=A(t,s,l);return y?{point:y.point,distance:y.distance,normal:y.normal,element:n,entering:b(t.direction,y.normal)<0}:null}function H(t,n){const e=(n.params.aperture||25)/2,i=D({x:0,y:1},n.rotation),a={x:n.position.x-i.x*e,y:n.position.y-i.y*e},s={x:n.position.x+i.x*e,y:n.position.y+i.y*e},l=A(t,a,s);return l?{point:l.point,distance:l.distance,normal:l.normal,element:n,entering:!0}:null}function Y(t,n){const e=(n.params.width||n.params.aperture||12)/2,i=D({x:0,y:1},n.rotation),a={x:n.position.x-i.x*e,y:n.position.y-i.y*e},s={x:n.position.x+i.x*e,y:n.position.y+i.y*e},l=A(t,a,s);return l?{point:l.point,distance:l.distance,normal:l.normal,element:n,entering:!0}:null}function O(t,n){const e=(n.params.aperture||25)/2,i=n.params.angle||45,a=n.rotation+i,s=D({x:0,y:1},a),l={x:n.position.x-s.x*e,y:n.position.y-s.y*e},y={x:n.position.x+s.x*e,y:n.position.y+s.y*e},p=A(t,l,y);return p?{point:p.point,distance:p.distance,normal:p.normal,element:n,entering:b(t.direction,p.normal)<0}:null}function z(t,n){const e=n.params.aperture||5,i=D({x:1,y:0},n.rotation),a=R(i),s=b(t.direction,i);if(Math.abs(s)<v)return null;const l=I(n.position,t.origin),y=b(l,i)/s;if(y<v)return null;const p={x:t.origin.x+t.direction.x*y,y:t.origin.y+t.direction.y*y},f=I(p,n.position),C=Math.abs(b(f,a));return C<e/2||C>50/2?null:{point:p,distance:y,normal:i,element:n,entering:!0}}function G(t,n,r){let e=null,i=1/0;for(const a of n){if(r&&a.id===r)continue;let s=null;switch(a.type){case"lens":s=T(t,a);break;case"mirror":s=H(t,a);break;case"detector":s=Y(t,a);break;case"aperture":s=z(t,a);break;case"beamsplitter":s=O(t,a);break;case"dichroic":s=O(t,a);break;case"filter":s=T(t,a);break}s&&s.distance<i&&(e=s,i=s.distance)}return e}function K(t,n){const r=n.element.params.focalLength||100,e=n.element.params.principalPlaneOffset||0,i=D({x:1,y:0},n.element.rotation),a=R(i),s={x:n.element.position.x+i.x*e,y:n.element.position.y+i.y*e},l=I(n.point,s),p=-b(l,a)/r*(180/Math.PI);return k(D(t.direction,p))}function Q(t){const r=(t.element.params.aperture||25)/2,e=R(D({x:1,y:0},t.element.rotation)),i=I(t.point,t.element.position);return Math.abs(b(i,e))>r}function L(t,n){const r=b(t,n);return k({x:t.x-2*r*n.x,y:t.y-2*r*n.y})}function X(t,n){const r=n.element.params.splitRatio||.5,e={...t,origin:n.point,intensity:t.intensity*r,id:U(),bounceCount:t.bounceCount+1},i=L(t.direction,n.normal),a={...t,origin:n.point,direction:i,intensity:t.intensity*(1-r),id:U(),bounceCount:t.bounceCount+1};return{transmitted:r>0?e:null,reflected:1-r>0?a:null}}function $(t,n){const r=n.element.params.cutoffWavelength||510;return(n.element.params.transmitAbove!==!1?t.wavelength>r:t.wavelength<r)?{transmitted:{...t,origin:n.point,bounceCount:t.bounceCount+1},reflected:null}:{transmitted:null,reflected:{...t,origin:n.point,direction:L(t.direction,n.normal),bounceCount:t.bounceCount+1}}}function F(t,n){const r=performance.now(),e=[],i=new Map,a=[],s=[];for(const c of t)c.type==="detector"&&i.set(c.id,{detectorId:c.id,moduleInstanceId:c.moduleInstanceId,totalPower:0,rayCount:0,centroid:{x:0,y:0},spread:{x:0,y:0},rayImpacts:[]});const l=t.filter(c=>c.type==="laser"||c.type==="led");if(l.length===0)return s.push({code:"NO_SOURCES",message:"No light sources in scene"}),{success:!1,rays:[],detectorReadings:[],warnings:a,errors:s,executionTimeMs:performance.now()-r,rayCount:0,segmentCount:0};let y=0;const p=[];for(const c of l){const o=j(c,n);p.push(...o)}const f=[];for(const c of p){const o=l.find(u=>Math.abs(u.position.x-c.origin.x)<50&&Math.abs(u.position.y-c.origin.y)<50);f.push({ray:c,segments:[],sourceId:o?.id||""})}for(;f.length>0;){const c=f.shift(),{ray:o,segments:u,sourceId:g}=c;if(o.bounceCount>=n.maxBounces){e.push({id:o.id,sourceId:g,segments:u,wavelength:o.wavelength,terminated:!0,terminationReason:"max_bounces"});continue}if(o.totalDistance>q){e.push({id:o.id,sourceId:g,segments:u,wavelength:o.wavelength,terminated:!0,terminationReason:"boundary"});continue}const d=G(o,t,u.length>0?u[u.length-1].rayId:void 0);if(!d){const m={x:o.origin.x+o.direction.x*500,y:o.origin.y+o.direction.y*500};u.push({start:o.origin,end:m,wavelength:o.wavelength,intensity:o.intensity,rayId:o.id}),y++,e.push({id:o.id,sourceId:g,segments:u,wavelength:o.wavelength,terminated:!0,terminationReason:"boundary"});continue}u.push({start:o.origin,end:d.point,wavelength:o.wavelength,intensity:o.intensity,rayId:o.id}),y++;const w=d.element;switch(w.type){case"lens":{if(Q(d)){e.push({id:o.id,sourceId:g,segments:u,wavelength:o.wavelength,terminated:!0,terminationReason:"absorbed"});break}const m=K(o,d),x={...o,origin:d.point,direction:m,bounceCount:o.bounceCount+1,totalDistance:o.totalDistance+d.distance};f.push({ray:x,segments:[...u],sourceId:g});break}case"mirror":{const m=w.params.reflectivity||.99,x=L(o.direction,d.normal),tt={...o,origin:d.point,direction:x,intensity:o.intensity*m,bounceCount:o.bounceCount+1,totalDistance:o.totalDistance+d.distance};f.push({ray:tt,segments:[...u],sourceId:g});break}case"beamsplitter":{const{transmitted:m,reflected:x}=X(o,d);m&&(m.totalDistance=o.totalDistance+d.distance,f.push({ray:m,segments:[...u],sourceId:g})),x&&(x.totalDistance=o.totalDistance+d.distance,f.push({ray:x,segments:[...u],sourceId:g}));break}case"dichroic":{const{transmitted:m,reflected:x}=$(o,d);m&&(m.totalDistance=o.totalDistance+d.distance,f.push({ray:m,segments:[...u],sourceId:g})),x&&(x.totalDistance=o.totalDistance+d.distance,f.push({ray:x,segments:[...u],sourceId:g}));break}case"detector":{const m=i.get(w.id);m&&(m.totalPower+=o.intensity,m.rayCount+=1,m.rayImpacts.push(d.point)),e.push({id:o.id,sourceId:g,segments:u,wavelength:o.wavelength,terminated:!0,terminationReason:"detector"});break}case"aperture":{e.push({id:o.id,sourceId:g,segments:u,wavelength:o.wavelength,terminated:!0,terminationReason:"absorbed"});break}case"filter":{const m=w.params.transmission||.5,x={...o,origin:d.point,intensity:o.intensity*m,bounceCount:o.bounceCount+1,totalDistance:o.totalDistance+d.distance};f.push({ray:x,segments:[...u],sourceId:g});break}default:a.push({code:"UNKNOWN_ELEMENT",message:`Unknown element type: ${w.type}`,elementId:w.id})}}const C=[];for(const c of i.values()){if(c.rayCount>0){let o=0,u=0;for(const w of c.rayImpacts)o+=w.x,u+=w.y;c.centroid={x:o/c.rayCount,y:u/c.rayCount};let g=0,d=0;for(const w of c.rayImpacts)g+=Math.pow(w.x-c.centroid.x,2),d+=Math.pow(w.y-c.centroid.y,2);c.spread={x:Math.sqrt(g/c.rayCount),y:Math.sqrt(d/c.rayCount)}}C.push(c)}return{success:!0,rays:e,detectorReadings:C,warnings:a,errors:s,executionTimeMs:performance.now()-r,rayCount:e.length,segmentCount:y}}let M=!1,N=!1;self.onmessage=t=>{const n=t.data;switch(n.type){case"run":J(n.elements,n.config);break;case"stop":Z();break}};function J(t,n){if(M){postMessage({type:"error",error:"Simulation already running"});return}M=!0,N=!1;try{postMessage({type:"progress",progress:0,rayCount:0});const r=F(t,n);if(N){M=!1;return}postMessage({type:"result",result:r})}catch(r){const e=r instanceof Error?r.message:"Unknown error";postMessage({type:"error",error:e})}M=!1}function Z(){N=!0,M=!1}})();
