(function(){"use strict";const m=[];for(let t=0;t<256;++t)m.push((t+256).toString(16).slice(1));function O(t,n=0){return(m[t[n+0]]+m[t[n+1]]+m[t[n+2]]+m[t[n+3]]+"-"+m[t[n+4]]+m[t[n+5]]+"-"+m[t[n+6]]+m[t[n+7]]+"-"+m[t[n+8]]+m[t[n+9]]+"-"+m[t[n+10]]+m[t[n+11]]+m[t[n+12]]+m[t[n+13]]+m[t[n+14]]+m[t[n+15]]).toLowerCase()}let A;const V=new Uint8Array(16);function q(){if(!A){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");A=crypto.getRandomValues.bind(crypto)}return A(V)}var L={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function U(t,n,r){if(L.randomUUID&&!t)return L.randomUUID();t=t||{};const o=t.random??t.rng?.()??q();if(o.length<16)throw new Error("Random bytes length must be >= 16");return o[6]=o[6]&15|64,o[8]=o[8]&63|128,O(o)}const I=1e-10,B=1e4;function v(t,n){return{x:t.x-n.x,y:t.y-n.y}}function W(t,n){return{x:t.x*n,y:t.y*n}}function w(t,n){return t.x*n.x+t.y*n.y}function P(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function S(t){const n=P(t);return n<I?{x:1,y:0}:{x:t.x/n,y:t.y/n}}function C(t,n){const r=n*Math.PI/180,o=Math.cos(r),i=Math.sin(r);return{x:t.x*o-t.y*i,y:t.x*i+t.y*o}}function R(t){return{x:-t.y,y:t.x}}function j(t,n){const r=[],o=t.params,i=o.rayCount||n.maxRays,a=o.wavelength||n.wavelength,s=o.divergence||0,l=o.beamDiameter||2,p=o.power||1,y=C({x:1,y:0},t.rotation);for(let g=0;g<i;g++){const D=i>1?(g/(i-1)-.5)*l:0,c=R(y),e={x:t.position.x+c.x*D,y:t.position.y+c.y*D};let u;if(s>0&&i>1){const h=(g/(i-1)-.5)*2*s;u=C(y,h)}else u=y;r.push({origin:e,direction:S(u),wavelength:a,intensity:p/i,id:U(),bounceCount:0,totalDistance:0})}return r}function k(t,n,r){const o=v(r,n),i=P(o);if(i<I)return null;const a=S(o),s=R(a),l=w(t.direction,s);if(Math.abs(l)<I)return null;const p=v(n,t.origin),y=w(p,s)/l;if(y<I)return null;const g={x:t.origin.x+t.direction.x*y,y:t.origin.y+t.direction.y*y},D=v(g,n),c=w(D,a);if(c<-I||c>i+I)return null;let e=s;return w(e,t.direction)>0&&(e=W(e,-1)),{point:g,distance:y,normal:e}}function T(t,n){const o=(n.params.aperture||25)/2,i=C({x:1,y:0},n.rotation),a=R(i),s={x:n.position.x-a.x*o,y:n.position.y-a.y*o},l={x:n.position.x+a.x*o,y:n.position.y+a.y*o},p=k(t,s,l);return p?{point:p.point,distance:p.distance,normal:p.normal,element:n,entering:w(t.direction,p.normal)<0}:null}function H(t,n){const o=(n.params.aperture||25)/2,i=C({x:0,y:1},n.rotation),a={x:n.position.x-i.x*o,y:n.position.y-i.y*o},s={x:n.position.x+i.x*o,y:n.position.y+i.y*o},l=k(t,a,s);return l?{point:l.point,distance:l.distance,normal:l.normal,element:n,entering:!0}:null}function Y(t,n){const o=(n.params.width||n.params.aperture||12)/2,i=C({x:0,y:1},n.rotation),a={x:n.position.x-i.x*o,y:n.position.y-i.y*o},s={x:n.position.x+i.x*o,y:n.position.y+i.y*o},l=k(t,a,s);return l?{point:l.point,distance:l.distance,normal:l.normal,element:n,entering:!0}:null}function _(t,n){const o=(n.params.aperture||25)/2,i=n.params.angle||45,a=n.rotation+i,s=C({x:0,y:1},a),l={x:n.position.x-s.x*o,y:n.position.y-s.y*o},p={x:n.position.x+s.x*o,y:n.position.y+s.y*o},y=k(t,l,p);return y?{point:y.point,distance:y.distance,normal:y.normal,element:n,entering:w(t.direction,y.normal)<0}:null}function z(t,n){const o=n.params.aperture||5,i=C({x:1,y:0},n.rotation),a=R(i),s=w(t.direction,i);if(Math.abs(s)<I)return null;const l=v(n.position,t.origin),p=w(l,i)/s;if(p<I)return null;const y={x:t.origin.x+t.direction.x*p,y:t.origin.y+t.direction.y*p},g=v(y,n.position),D=Math.abs(w(g,a));return D<o/2||D>50/2?null:{point:y,distance:p,normal:i,element:n,entering:!0}}function G(t,n,r){let o=null,i=1/0;for(const a of n){if(r&&a.id===r)continue;let s=null;switch(a.type){case"lens":s=T(t,a);break;case"mirror":s=H(t,a);break;case"detector":s=Y(t,a);break;case"aperture":s=z(t,a);break;case"beamsplitter":s=_(t,a);break;case"dichroic":s=_(t,a);break;case"filter":s=T(t,a);break}s&&s.distance<i&&(o=s,i=s.distance)}return o}function K(t,n){const r=n.element.params.focalLength||100,o=v(n.point,n.element.position),i=C({x:1,y:0},n.element.rotation),a=R(i),l=-w(o,a)/r*(180/Math.PI);return S(C(t.direction,l))}function N(t,n){const r=w(t,n);return S({x:t.x-2*r*n.x,y:t.y-2*r*n.y})}function Q(t,n){const r=n.element.params.splitRatio||.5,o={...t,origin:n.point,intensity:t.intensity*r,id:U(),bounceCount:t.bounceCount+1},i=N(t.direction,n.normal),a={...t,origin:n.point,direction:i,intensity:t.intensity*(1-r),id:U(),bounceCount:t.bounceCount+1};return{transmitted:r>0?o:null,reflected:1-r>0?a:null}}function X(t,n){const r=n.element.params.cutoffWavelength||510;return(n.element.params.transmitAbove!==!1?t.wavelength>r:t.wavelength<r)?{transmitted:{...t,origin:n.point,bounceCount:t.bounceCount+1},reflected:null}:{transmitted:null,reflected:{...t,origin:n.point,direction:N(t.direction,n.normal),bounceCount:t.bounceCount+1}}}function $(t,n){const r=performance.now(),o=[],i=new Map,a=[],s=[];for(const c of t)c.type==="detector"&&i.set(c.id,{detectorId:c.id,moduleInstanceId:c.moduleInstanceId,totalPower:0,rayCount:0,centroid:{x:0,y:0},spread:{x:0,y:0},rayImpacts:[]});const l=t.filter(c=>c.type==="laser"||c.type==="led");if(l.length===0)return s.push({code:"NO_SOURCES",message:"No light sources in scene"}),{success:!1,rays:[],detectorReadings:[],warnings:a,errors:s,executionTimeMs:performance.now()-r,rayCount:0,segmentCount:0};let p=0;const y=[];for(const c of l){const e=j(c,n);y.push(...e)}const g=[];for(const c of y){const e=l.find(u=>Math.abs(u.position.x-c.origin.x)<50&&Math.abs(u.position.y-c.origin.y)<50);g.push({ray:c,segments:[],sourceId:e?.id||""})}for(;g.length>0;){const c=g.shift(),{ray:e,segments:u,sourceId:h}=c;if(e.bounceCount>=n.maxBounces){o.push({id:e.id,sourceId:h,segments:u,wavelength:e.wavelength,terminated:!0,terminationReason:"max_bounces"});continue}if(e.totalDistance>B){o.push({id:e.id,sourceId:h,segments:u,wavelength:e.wavelength,terminated:!0,terminationReason:"boundary"});continue}const d=G(e,t,u.length>0?u[u.length-1].rayId:void 0);if(!d){const f={x:e.origin.x+e.direction.x*500,y:e.origin.y+e.direction.y*500};u.push({start:e.origin,end:f,wavelength:e.wavelength,intensity:e.intensity,rayId:e.id}),p++,o.push({id:e.id,sourceId:h,segments:u,wavelength:e.wavelength,terminated:!0,terminationReason:"boundary"});continue}u.push({start:e.origin,end:d.point,wavelength:e.wavelength,intensity:e.intensity,rayId:e.id}),p++;const b=d.element;switch(b.type){case"lens":{const f=K(e,d),x={...e,origin:d.point,direction:f,bounceCount:e.bounceCount+1,totalDistance:e.totalDistance+d.distance};g.push({ray:x,segments:[...u],sourceId:h});break}case"mirror":{const f=b.params.reflectivity||.99,x=N(e.direction,d.normal),Z={...e,origin:d.point,direction:x,intensity:e.intensity*f,bounceCount:e.bounceCount+1,totalDistance:e.totalDistance+d.distance};g.push({ray:Z,segments:[...u],sourceId:h});break}case"beamsplitter":{const{transmitted:f,reflected:x}=Q(e,d);f&&(f.totalDistance=e.totalDistance+d.distance,g.push({ray:f,segments:[...u],sourceId:h})),x&&(x.totalDistance=e.totalDistance+d.distance,g.push({ray:x,segments:[...u],sourceId:h}));break}case"dichroic":{const{transmitted:f,reflected:x}=X(e,d);f&&(f.totalDistance=e.totalDistance+d.distance,g.push({ray:f,segments:[...u],sourceId:h})),x&&(x.totalDistance=e.totalDistance+d.distance,g.push({ray:x,segments:[...u],sourceId:h}));break}case"detector":{const f=i.get(b.id);f&&(f.totalPower+=e.intensity,f.rayCount+=1,f.rayImpacts.push(d.point)),o.push({id:e.id,sourceId:h,segments:u,wavelength:e.wavelength,terminated:!0,terminationReason:"detector"});break}case"aperture":{o.push({id:e.id,sourceId:h,segments:u,wavelength:e.wavelength,terminated:!0,terminationReason:"absorbed"});break}case"filter":{const f=b.params.transmission||.5,x={...e,origin:d.point,intensity:e.intensity*f,bounceCount:e.bounceCount+1,totalDistance:e.totalDistance+d.distance};g.push({ray:x,segments:[...u],sourceId:h});break}default:a.push({code:"UNKNOWN_ELEMENT",message:`Unknown element type: ${b.type}`,elementId:b.id})}}const D=[];for(const c of i.values()){if(c.rayCount>0){let e=0,u=0;for(const b of c.rayImpacts)e+=b.x,u+=b.y;c.centroid={x:e/c.rayCount,y:u/c.rayCount};let h=0,d=0;for(const b of c.rayImpacts)h+=Math.pow(b.x-c.centroid.x,2),d+=Math.pow(b.y-c.centroid.y,2);c.spread={x:Math.sqrt(h/c.rayCount),y:Math.sqrt(d/c.rayCount)}}D.push(c)}return{success:!0,rays:o,detectorReadings:D,warnings:a,errors:s,executionTimeMs:performance.now()-r,rayCount:o.length,segmentCount:p}}let M=!1,E=!1;self.onmessage=t=>{const n=t.data;switch(n.type){case"run":F(n.elements,n.config);break;case"stop":J();break}};function F(t,n){if(M){postMessage({type:"error",error:"Simulation already running"});return}M=!0,E=!1;try{postMessage({type:"progress",progress:0,rayCount:0});const r=$(t,n);if(E){M=!1;return}postMessage({type:"result",result:r})}catch(r){const o=r instanceof Error?r.message:"Unknown error";postMessage({type:"error",error:o})}M=!1}function J(){E=!0,M=!1}})();
